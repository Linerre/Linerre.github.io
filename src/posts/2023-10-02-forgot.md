---
title: (Good) Things I sometimes forgot when coding
date: 2023-10-02
summary: After coding for a while, I find I sometimes forgot the (good) code.
---

After coding for a while, I now find myself, from time to time, caught in situations where I wrote some bad(-style) code because I forgot the good.  The reasons vary but this one stands out: I did *not* really take a concept or definition seriously at the very beginning and did not make it a habit.  This post is therefore a note for now and future me.

## `if` statement vs `if` expression block
In Python's term, `if` is a [*statement*](https://docs.python.org/3/tutorial/controlflow.html) instead of *expression*.   In Python's `if` blocks, rarely did I even think about returning a value or result.

In Rust, however, since `if` is followed by a `block`, it can also act as [expressions](https://doc.rust-lang.org/std/keyword.if.html), which means it is fairly common in Rust to return a value from a `if` block:

``` rust
// Common practice
let x = if a != 10 { a } else { a + 1 };

// Instead of this
let mut x = 0;
if a != 10 {
    x = a;
} else {
    x = a + 1;
}
```

Or in [Haskell](https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-320003.6), the mandatory `else` branch requires something to be returned:

``` haskell
doubleSmallNumber x = (if x = 10 then x else x*2) + 1
```

Or in [Clojure](https://clojure.org/reference/special_forms#if):

``` clojure
(if (= a 10)
  a
  (* a 2))
```


## boolean expressions
My die-hard habit is the following:
``` rust
if x != 10 {
    correct = false;
} else {
    correct = true;
}
```

But why not simply this:
``` rust
correct = x != 10;
```

In many languages, when an expression evaluates to a value, I should use the expression's return value, rather than *merely* evaluate it.


## `.length` v.s. `len()`
It's normal to loop over an array using something like
``` java
for (int i=0; i < arr.length; i++) // do sth here
```

In Java the `length` property of an array is [static](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html) and determined at compile time.  That means accessing its value is of `O(1)` time complexity.

Yet for dynamical arrays (a.k.a vectors in some other languages), using `len()` method has some overhead.  Thus, it is good to store the length in a variable and use it thereafter (assuming the /length/ doesn't change, of course)

``` java
int N = someArr.len();
for (int i=0; i<N; i++) // do sth here
```

## namespace
I often need to work with a few programming languages at the same time (well, who doesn't).  They have similar concepts and thus can be confused with each other.  Namespace is such an example of confusion.

In C++, as far as Standard Libraries are concerned, I'll need to
1. `#include` any header files into current scope first or `using namepsace std` if possible
2. Use whatever in `std::<stuff>`
``` cpp
#include <string>
string my_str = "cpp";

// Otherwise
std::string my_str = "cpp";
```

In Rust, the `prelude` is already there, yet I'll still need to explicitly `use` such features as `std::collection` (for various maps and so on) and `std::sync` for locks.
``` rust
let name = "rust"; // &str
let name2 = String::from("rust"); // No need to include anything for `String'

// But need to explicitly import collections
use std::collection::HashMap;
let students = HashMap::<String, u8>::new();
```

In Clojure, a convenient shorthand is this: mark any vars and fns with double colons `::` so that they will be prefixed with current namespace automatically.
``` clojure
(ns my-libs)

;; It will become :my-libs/helper when used somewhere else
(defn ::helper []
  ;; body
  )
```

## indicating possible failure in initialization
In Rust, when initializing an instance of my own types (usually `struct`), I can use different function names to indicate different results
``` rust
struct Student {
    name: &str,
    age: u8,
}

// For sake of simplicity, I ignore lifecycle of &str here
impl Student {
    fn new(name: &str, age: u8) -> Self {
        Self {name, age}
    }

    // Indicate it may fail to initialize a new student
    fn try_new(name &str, age: u8) -> Result<Self, MyError> {
        Ok(Self {name, age})
    }
}
```

## think about the "forest" all time
When coding, it's easy for me to get obsessed with specific implementations/details/steps only to find I wasted much time later ... It's good to always keep the whole picture in mind. Thus instead of rushing into coding, I should make good plans:
``` cpp
int main()
{
  FirstThing();
  SecondThing();
}
```
Then work on `FirstThing()`, and then `SecondThing()`. A basic plan always helps.

[^5]:
